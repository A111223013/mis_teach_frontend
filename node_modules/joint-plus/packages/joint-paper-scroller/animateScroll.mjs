function swing(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;

    return 0.5 - Math.cos(t * Math.PI) / 2;
}

export default function animateScroll(element, target, opt) {
    const {
        duration = 400,
        timingFunction = swing,
        complete
    } = opt;
    const startTime = Date.now();
    const endTime = startTime + duration;

    // get the current scroll position
    const initialScrollLeft = element.scrollLeft;
    const initialScrollTop = element.scrollTop;

    const targetLeft = target.scrollLeft || initialScrollLeft;
    const targetTop = target.scrollTop || initialScrollTop;

    // calculate the difference between the current scroll position and the target
    const horizontalDistance = targetLeft - initialScrollLeft;
    const verticalDistance = targetTop - initialScrollTop;

    let timeoutId;

    // the animation function
    function animate() {
        const now = Date.now();
        const progress = (now - startTime) / (endTime - startTime); // interpolation
        const point = timingFunction(progress);

        const frameLeft = Math.round(initialScrollLeft + (horizontalDistance * point));
        const frameTop = Math.round(initialScrollTop + (verticalDistance * point));
        element.scrollLeft = frameLeft;
        element.scrollTop = frameTop;

        // check if we're done
        if (now >= endTime) {
            complete && complete();
            return;
        }

        // If we were supposed to scroll but didn't, then we
        // probably hit the limit, so consider it done; not
        // interrupted.
        if (element.scrollLeft !== frameLeft && element.scrollTop !== frameTop) {
            complete && complete();
            return;
        }

        // schedule next frame for execution
        timeoutId = setTimeout(animate, 0);
    }

    // start the animation
    animate();

    return () => clearTimeout(timeoutId);
}
